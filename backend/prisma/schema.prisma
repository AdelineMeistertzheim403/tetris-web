datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
}

model User {
  id        Int      @id @default(autoincrement())
  pseudo    String   @unique
  email     String   @unique
  password  String
  scores    Score[]
  versusAsPlayer1 VersusMatch[] @relation("VersusPlayer1")
  versusAsPlayer2 VersusMatch[] @relation("VersusPlayer2")
  versusAsWinner  VersusMatch[] @relation("VersusWinner")
  brickfallVersusAsPlayer1 BrickfallVersusMatch[] @relation("BrickfallVersusPlayer1")
  brickfallVersusAsPlayer2 BrickfallVersusMatch[] @relation("BrickfallVersusPlayer2")
  brickfallVersusAsWinner  BrickfallVersusMatch[] @relation("BrickfallVersusWinner")
  roguelikeVersusAsPlayer1 RoguelikeVersusMatch[] @relation("RoguelikeVersusPlayer1")
  roguelikeVersusAsPlayer2 RoguelikeVersusMatch[] @relation("RoguelikeVersusPlayer2")
  roguelikeVersusAsWinner  RoguelikeVersusMatch[] @relation("RoguelikeVersusWinner")
   roguelikeRuns RoguelikeRun[]
  puzzleAttempts PuzzleAttempt[]
  puzzleSolutions PuzzleSolution[]
  achievements UserAchievement[]
  achievementStats UserAchievementStats?
  brickfallSoloProgress BrickfallSoloProgress?
  brickfallSoloCustomLevels BrickfallSoloCustomLevel[]
  createdAt DateTime @default(now())
}

model Score {
  id        Int      @id @default(autoincrement())
  value     Int
  level     Int
  lines     Int
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  createdAt DateTime @default(now())
  mode      GameMode @default(CLASSIQUE)
}

model VersusMatch {
  id             Int      @id @default(autoincrement())
  matchId        String?
  player1Id      Int?
  player1Pseudo  String
  player1Score   Int
  player1Lines   Int
  player2Id      Int?
  player2Pseudo  String
  player2Score   Int
  player2Lines   Int
  winnerId       Int?
  winnerPseudo   String?
  createdAt      DateTime @default(now())

  player1 User? @relation("VersusPlayer1", fields: [player1Id], references: [id])
  player2 User? @relation("VersusPlayer2", fields: [player2Id], references: [id])
  winner  User? @relation("VersusWinner", fields: [winnerId], references: [id])
}

model RoguelikeVersusMatch {
  id             Int      @id @default(autoincrement())
  matchId        String?
  player1Id      Int?
  player1Pseudo  String
  player1Score   Int
  player1Lines   Int
  player2Id      Int?
  player2Pseudo  String
  player2Score   Int
  player2Lines   Int
  winnerId       Int?
  winnerPseudo   String?
  createdAt      DateTime @default(now())

  player1 User? @relation("RoguelikeVersusPlayer1", fields: [player1Id], references: [id])
  player2 User? @relation("RoguelikeVersusPlayer2", fields: [player2Id], references: [id])
  winner  User? @relation("RoguelikeVersusWinner", fields: [winnerId], references: [id])
}

model BrickfallVersusMatch {
  id             Int      @id @default(autoincrement())
  matchId        String?
  player1Id      Int?
  player1Pseudo  String
  player1Role    BrickfallRole
  player1Score   Int
  player1Lines   Int
  player2Id      Int?
  player2Pseudo  String
  player2Role    BrickfallRole
  player2Score   Int
  player2Lines   Int
  winnerId       Int?
  winnerPseudo   String?
  createdAt      DateTime @default(now())

  player1 User? @relation("BrickfallVersusPlayer1", fields: [player1Id], references: [id])
  player2 User? @relation("BrickfallVersusPlayer2", fields: [player2Id], references: [id])
  winner  User? @relation("BrickfallVersusWinner", fields: [winnerId], references: [id])
}

model RoguelikeRun {
  id                Int      @id @default(autoincrement())
  userId            Int

  seed              String
  state             Json
  
  score             BigInt
  lines             Int
  level             Int

  perks             Json     // tableau d’ids de perks
  mutations         Json     // array of mutation ids and stacks
  bombs             Int
  timeFreezeCharges Int
  chaosMode         Boolean

  gravityMultiplier Float
  scoreMultiplier   Float

  status            RunStatus
  createdAt         DateTime @default(now())
  endedAt           DateTime?

  user              User     @relation(fields: [userId], references: [id])
}

model Achievement {
  id          String   @id
  name        String
  description String
  icon        String
  category    String   // run, combat, bomb, chaos, mastery…
  hidden      Boolean  @default(false)
  users       UserAchievement[]
}

model UserAchievement {
  userId        Int
  achievementId String
  unlockedAt    DateTime @default(now())

  user          User        @relation(fields: [userId], references: [id])
  achievement   Achievement @relation(fields: [achievementId], references: [id])

  @@id([userId, achievementId])
}

model UserAchievementStats {
  userId     Int      @id
  loginDays  Json     @default("[]")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user       User     @relation(fields: [userId], references: [id])
}

model BrickfallSoloProgress {
  userId       Int      @id
  highestLevel Int      @default(1)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User     @relation(fields: [userId], references: [id])
}

model BrickfallSoloCustomLevel {
  id         Int      @id @default(autoincrement())
  userId     Int
  levelId    String
  definition Json
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, levelId])
  @@index([userId, updatedAt])
}

enum RunStatus {
  IN_PROGRESS
  FINISHED
  ABANDONED
}

enum GameMode {
  CLASSIQUE
  SPRINT
  VERSUS
  BRICKFALL_VERSUS
  ROGUELIKE_VERSUS
}

enum BrickfallRole {
  ARCHITECT
  DEMOLISHER
}

model Puzzle {
  id          String   @id
  name        String
  description String
  difficulty  String   @default("normal")
  definition  Json
  active      Boolean  @default(true)
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  attempts PuzzleAttempt[]
  solutions PuzzleSolution[]
}

model PuzzleAttempt {
  id              Int      @id @default(autoincrement())
  puzzleId        String
  userId          Int
  success         Boolean
  movesUsed       Int
  linesCleared    Int
  piecesPlaced    Int
  holdUsed        Boolean
  efficiencyScore Int
  optimal         Boolean  @default(false)
  createdAt       DateTime @default(now())

  puzzle Puzzle @relation(fields: [puzzleId], references: [id])
  user   User   @relation(fields: [userId], references: [id])

  @@index([userId, puzzleId])
}

model PuzzleSolution {
  id        Int      @id @default(autoincrement())
  puzzleId  String
  userId    Int
  movesUsed Int
  data      Json
  optimal   Boolean  @default(false)
  createdAt DateTime @default(now())

  puzzle Puzzle @relation(fields: [puzzleId], references: [id])
  user   User   @relation(fields: [userId], references: [id])

  @@index([userId, puzzleId])
}
